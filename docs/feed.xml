<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-04-17T12:50:03+12:00</updated><id>/feed.xml</id><title type="html">Thomas Bidne</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Whence cometh optics?</title><link href="/posts/optics/" rel="alternate" type="text/html" title="Whence cometh optics?" /><published>2023-04-14T12:00:00+12:00</published><updated>2023-04-14T12:00:00+12:00</updated><id>/posts/optics</id><content type="html" xml:base="/posts/optics/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p><strong>Optics</strong> are a powerful tool in certain niche areas of programming, but they can be confusing and intimidating, especially for those coming from a more traditional programming background. What are optics, why would one use them, and should you care? This post will explore each of these questions.</p>

<p>This is not a comprehensive overview of optics, nor is it an explanation of how they work. Rather, it is an introduction to the topic, motivated by the problem they were designed to solve.</p>

<h2 id="classic-getterssetters">Classic Getters/Setters</h2>

<p>The core concept involves data “getters and setters”, so let’s look at a traditional example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Email</span> <span class="o">{</span>
  <span class="c1">// i.e. local@domain</span>
  <span class="nc">String</span> <span class="n">local</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="nc">String</span> <span class="n">domain</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Email</span><span class="o">(</span><span class="nc">String</span> <span class="n">local</span><span class="o">,</span> <span class="nc">String</span> <span class="n">domain</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getLocal</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">local</span><span class="o">;</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLocal</span><span class="o">(</span><span class="nc">String</span> <span class="n">local</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">local</span> <span class="o">=</span> <span class="n">local</span><span class="o">;</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getDomain</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">domain</span><span class="o">;</span> <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDomain</span><span class="o">(</span><span class="nc">String</span> <span class="n">domain</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The getters (<code class="language-plaintext highlighter-rouge">getLocal</code> and <code class="language-plaintext highlighter-rouge">getDomain</code>) are used to retrieve the field while the setters (<code class="language-plaintext highlighter-rouge">setLocal</code> and <code class="language-plaintext highlighter-rouge">setDomain</code>) are used to set the field.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="c1">// get fields</span>
<span class="nc">String</span> <span class="n">localVar</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="na">getLocal</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">domainVar</span> <span class="o">=</span> <span class="n">email</span><span class="o">.</span><span class="na">getDomain</span><span class="o">();</span>

<span class="c1">// set fields</span>
<span class="n">email</span><span class="o">.</span><span class="na">setLocal</span><span class="o">(</span><span class="s">"username"</span><span class="o">);</span>
<span class="n">email</span><span class="o">.</span><span class="na">setDomain</span><span class="o">(</span><span class="s">"domain.com"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We can view <code class="language-plaintext highlighter-rouge">getLocal</code> as a function that takes an <code class="language-plaintext highlighter-rouge">Email</code> (implicit <code class="language-plaintext highlighter-rouge">this</code>) and returns a <code class="language-plaintext highlighter-rouge">String</code>. Similarly, <code class="language-plaintext highlighter-rouge">setLocal</code> can be viewed as a function that takes a <code class="language-plaintext highlighter-rouge">String</code>, an <code class="language-plaintext highlighter-rouge">Email</code> (<code class="language-plaintext highlighter-rouge">this</code>), and returns a new <code class="language-plaintext highlighter-rouge">Email</code> (modified <code class="language-plaintext highlighter-rouge">this</code>). That is:</p>

\[\begin{align*}
  &amp; \text{getLocal} : \text{Email} \to \text{String} \\
  &amp; \text{setLocal} : \text{String} \times \text{Email} \to \text{Email}
\end{align*}\]

<p>Together, a getter + setter pair for a given field represents a way to “focus” on a particular field.</p>

<p>A nice thing about typical getters/setters is that they can be <em>composed</em>. That is, if I have</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
  <span class="nc">Integer</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="nc">Email</span> <span class="n">email</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nc">Email</span> <span class="nf">getEmail</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">email</span><span class="o">;</span> <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setEmail</span><span class="o">(</span><span class="nc">Email</span> <span class="n">email</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Then we can compose the getters/setters together:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nc">String</span> <span class="n">localVar</span> <span class="o">=</span> <span class="n">customer</span><span class="o">.</span><span class="na">getEmail</span><span class="o">().</span><span class="na">getLocal</span><span class="o">();</span>

<span class="n">customer</span><span class="o">.</span><span class="na">getEmail</span><span class="o">().</span><span class="na">setLocal</span><span class="o">(</span><span class="s">"username"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="haskell-getterssetters">Haskell Getters/Setters</h2>

<p>Optics are most commonly used in Haskell, so let’s look at how we would replicate the above java. First, let’s create the equivalent types.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kr">data</span> <span class="kt">Email</span>
  <span class="o">=</span> <span class="kt">MkEmail</span>
    <span class="p">{</span> <span class="n">local</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span>
      <span class="n">domain</span> <span class="o">::</span> <span class="kt">String</span>
    <span class="p">}</span>

<span class="kr">data</span> <span class="kt">Customer</span>
  <span class="o">=</span> <span class="kt">MkCustomer</span>
    <span class="p">{</span> <span class="n">id</span> <span class="o">::</span> <span class="kt">Integer</span><span class="p">,</span>
      <span class="n">email</span> <span class="o">::</span> <span class="kt">Email</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With this “record syntax” haskell gives us “selectors” that are similar to java getters/setters.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="c1">-- analogous to "email.getLocal()". Notice this is "backwards" as the 'local'</span>
<span class="c1">-- and 'domain' "fields" are essentially functions.</span>
<span class="c1">--</span>
<span class="c1">-- local : Email -&gt; String</span>
<span class="c1">-- domain : Email -&gt; String</span>
<span class="kr">let</span> <span class="n">localVar</span> <span class="o">::</span> <span class="kt">String</span>
    <span class="n">localVar</span> <span class="o">=</span> <span class="n">local</span> <span class="n">email</span>

    <span class="n">domainVar</span> <span class="o">::</span> <span class="kt">String</span>
    <span class="n">domainVar</span> <span class="o">=</span> <span class="n">domain</span> <span class="n">email</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Updates are more interesting. Data in haskell is <em>immutable</em> i.e. once you declare something it is constant; it cannot be changed. This is an enormously useful feature, but it poses a problem. Even if we do not need true mutability, we often want to <em>model</em> it. How do we do this in an immutable world? Well, we have to create <em>new</em> data that copies the old fields over together with the new field.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">-- How we implement email.setLocal("username"). Analogous to</span>
<span class="c1">-- Email newEmail = new Email("username", email.getDomain())</span>
<span class="kr">let</span> <span class="n">newEmail</span> <span class="o">::</span> <span class="kt">Email</span>
    <span class="n">newEmail</span> <span class="o">=</span> <span class="kt">MkEmail</span> <span class="s">"username"</span> <span class="p">(</span><span class="n">domain</span> <span class="n">email</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Luckily, haskell provides an “update syntax” that makes this more reasonable.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">-- Analogous to email.setLocal("username")</span>
<span class="kr">let</span> <span class="n">newEmail</span> <span class="o">::</span> <span class="kt">Email</span>
    <span class="n">newEmail</span> <span class="o">=</span> <span class="n">email</span> <span class="p">{</span> <span class="n">local</span> <span class="o">=</span> <span class="s">"username"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Make no mistake, in neither case are we actually modifying the original <code class="language-plaintext highlighter-rouge">email</code>. It is constant. We are creating a new email with the fields we want, thus <em>modeling</em> mutability, which is usually all we need.</p>

<h2 id="the-problem">The problem</h2>

<p>So far this works well, ergonomics notwithstanding. What about the nested case? Getting works fine:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">-- customer.getEmail().getLocal()</span>
<span class="kr">let</span> <span class="n">localVar</span> <span class="o">::</span> <span class="kt">String</span>
    <span class="n">localVar</span> <span class="o">=</span> <span class="n">local</span> <span class="p">(</span><span class="n">email</span> <span class="n">customer</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It is update that is the problem. The update syntax we saw earlier cannot be nested. That is, the following is not legal:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">-- customer.getEmail().setLocal("username")</span>
<span class="kr">let</span> <span class="n">newCustomer</span> <span class="o">::</span> <span class="kt">Customer</span>
    <span class="n">newCustomer</span> <span class="o">=</span> <span class="n">customer</span> <span class="p">{</span> <span class="n">email</span> <span class="o">=</span> <span class="p">{</span> <span class="n">local</span> <span class="o">=</span> <span class="s">"username"</span> <span class="p">}</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We are thus stuck copying fields manually:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kr">let</span> <span class="c1">-- newEmail = customer.getEmail().set("username");</span>
    <span class="n">newEmail</span> <span class="o">::</span> <span class="kt">Email</span>
    <span class="n">newEmail</span> <span class="o">=</span> <span class="p">(</span><span class="n">email</span> <span class="n">customer</span><span class="p">)</span> <span class="p">{</span> <span class="n">local</span> <span class="o">=</span> <span class="s">"username"</span> <span class="p">}</span>

    <span class="c1">-- newCustomer = new Customer(customer.getId(), newEmail)</span>
    <span class="n">newCustomer</span> <span class="o">::</span> <span class="kt">Customer</span>
    <span class="n">newCustomer</span> <span class="o">=</span> <span class="kt">MkCustomer</span> <span class="p">(</span><span class="n">id</span> <span class="n">customer</span><span class="p">)</span> <span class="n">newEmail</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>It is as if we had to do the following in java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">// rather than customer.getEmail().setLocal("username")</span>

<span class="c1">// create newEmail with the new field</span>
<span class="nc">Email</span> <span class="n">newEmail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Email</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">email</span><span class="o">.</span><span class="na">getDomain</span><span class="o">());</span>
<span class="c1">// create a new Customer w/ our changed field</span>
<span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">newEmail</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Obviously this does not scale at all. Something like:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">x</span><span class="o">.</span><span class="na">getA</span><span class="o">().</span><span class="na">getB</span><span class="o">().</span><span class="na">setC</span><span class="o">(</span><span class="k">new</span> <span class="no">C</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>would become</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="no">C</span> <span class="n">newC</span> <span class="o">=</span> <span class="k">new</span> <span class="no">C</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="no">B</span> <span class="n">newB</span> <span class="o">=</span> <span class="k">new</span> <span class="no">B</span><span class="o">(</span><span class="n">newC</span><span class="o">);</span>
<span class="no">A</span> <span class="n">newA</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A</span><span class="o">(</span><span class="n">newB</span><span class="o">);</span>
<span class="n">x</span> <span class="n">newX</span> <span class="o">=</span> <span class="k">new</span> <span class="no">X</span><span class="o">(</span><span class="n">newA</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>In other words, <em>nested</em> updates and immutable data do not mix well. It is this problem that optics are designed to solve.</p>

<h2 id="lenses">Lenses</h2>

<p>There are many types of optics, but for our purposes we will only consider <strong>lenses</strong>, arguably the easiest to motivate. Lenses take the idea of a “getter/setter pair” and turn this into actual data. Without getting into the implementation, a lens in haskell looks something like:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">emailLocalLens</span> <span class="o">::</span> <span class="kt">Lens</span> <span class="kt">Email</span> <span class="kt">String</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>That is, <code class="language-plaintext highlighter-rouge">emailLocalLens</code> represents the concept of “getting and setting the field local” on the type <code class="language-plaintext highlighter-rouge">Email</code>. This gives us an alternative to the selectors used before:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="c1">-- Like email.getLocal(). 'view' is a function that takes in a lens, data and</span>
<span class="c1">-- "activates" the getter portion of the lens to get the desired field. Morally,</span>
<span class="c1">--</span>
<span class="c1">-- view :: Lens s a -&gt; s -&gt; a</span>
<span class="kr">let</span> <span class="n">localVar</span> <span class="o">::</span> <span class="kt">String</span>
    <span class="n">localVar</span> <span class="o">=</span> <span class="n">view</span> <span class="n">emailLocalLens</span> <span class="n">email</span>

<span class="c1">-- Like email.setLocal("username"). 'set' is a function that takes in a lens, the</span>
<span class="c1">-- new value, data and "activates" the setter portion of the lens to set the</span>
<span class="c1">-- desired field. Morally,</span>
<span class="c1">--</span>
<span class="c1">-- set :: Lens s a -&gt; a -&gt; s -&gt; s</span>
<span class="kr">let</span> <span class="n">newEmail</span> <span class="o">::</span> <span class="kt">Email</span>
    <span class="n">newEmail</span> <span class="o">=</span> <span class="n">set</span> <span class="n">emailLocalLens</span> <span class="s">"username"</span> <span class="n">email</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is why lenses are referred to as “first class getters/setters”. Rather than having some syntax built into the language (e.g. java methods), lenses are just like anything else in haskell: a type we can define ourselves that implements the “getter/setter” concept with respect to some data.</p>

<p>At this point you would be forgiven for wondering what that point is. This seems like a lot of work just to come up with a worse syntax. Why go through all this trouble? The crucial advantage that lenses have over traditional haskell updates is that they can be <em>composed</em>. Remember the previous example?</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kr">let</span> <span class="n">newEmail</span> <span class="o">=</span> <span class="n">email</span> <span class="p">{</span> <span class="n">local</span> <span class="o">=</span> <span class="s">"username"</span> <span class="p">}</span>
    <span class="n">newCustomer</span> <span class="o">=</span> <span class="kt">MkCustomer</span> <span class="n">newEmail</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>With lenses we don’t have to manually copy over all the old data:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">-- customerEmailLens is a lens for the email field on the Customer type</span>
<span class="n">customerEmailLens</span> <span class="o">::</span> <span class="kt">Lens</span> <span class="kt">Customer</span> <span class="kt">Email</span>

<span class="kr">let</span> <span class="c1">-- We can freely compose (combine) lenses together</span>
    <span class="n">customerLocalLens</span> <span class="o">::</span> <span class="kt">Lens</span> <span class="kt">Customer</span> <span class="kt">String</span>
    <span class="n">customerLocalLens</span> <span class="o">=</span> <span class="n">customerEmailLens</span> <span class="o">.</span> <span class="n">emailLocalLens</span>

    <span class="n">newCustomer</span> <span class="o">::</span> <span class="kt">Customer</span>
    <span class="n">newCustomer</span> <span class="o">=</span> <span class="n">set</span> <span class="n">customerLocalLens</span> <span class="s">"username"</span> <span class="n">customer</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The advantage is easily seen with the “extreme” example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">x</span><span class="o">.</span><span class="na">getA</span><span class="o">().</span><span class="na">getB</span><span class="o">().</span><span class="na">setC</span><span class="o">(</span><span class="k">new</span> <span class="no">C</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kr">let</span> <span class="n">newX</span> <span class="o">=</span> <span class="n">set</span> <span class="p">(</span><span class="n">aLens</span> <span class="o">.</span> <span class="n">bLens</span> <span class="o">.</span> <span class="n">cLens</span><span class="p">)</span> <span class="mi">5</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Thus we arrive at the primary motivation. Even if we do not need <strong>true</strong> mutability, we often need to model it. This can be quite difficult with immutable data. Unless our language provides special syntax for it, we have to manually recreate the data. Lenses exist to recover the ergonomics of mutability (i.e. nested getters/setters) in an immutable world.</p>

<h2 id="should-you-care">Should you care?</h2>

<p>If you are working in an environment with immutable data then lenses (and other optics) are certainly worth being aware of. They are never necessary, but they can make life much easier.</p>

<p>However, this is not the world inhabited by most programming. For better or worse, most programming languages fully embrace true mutability, thus we immediately have access to nested getters/setters. In this world, should you care about lenses?</p>

<p>Probably not, as a major motivator is gone. Java doesn’t have this problem as all data is mutable, thus there is little need to torture yourself trying to implement lenses in java (of course, <a href="https://github.com/Mojang/DataFixerUpper/blob/master/src/main/java/com/mojang/datafixers/optics/Lens.java">masochism exists</a>).</p>

<p>To put it more directly, you do not typically want to use lenses for their own sake, as an alternative to normal getters/setters. You use them because you want to use immutable data, and lenses help immutability suck less.</p>

<h2 id="addendum">Addendum</h2>

<p>While composition is the primary motivation for lenses, it isn’t the only advantage.</p>

<p>In java you are mildly screwed if you want to update a field, rather than just set it.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="no">C</span> <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">getA</span><span class="o">().</span><span class="na">getB</span><span class="o">().</span><span class="na">getC</span><span class="o">();</span>
<span class="n">c</span><span class="o">.</span><span class="na">setVal</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getVal</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// can't do this inline</span>
<span class="n">x</span><span class="o">.</span><span class="na">getA</span><span class="o">().</span><span class="na">getB</span><span class="o">().</span><span class="na">setC</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Lenses handle this just fine:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">-- 'over' takes in a lens, a _function_, and the data to modify. Morally,</span>
<span class="c1">--</span>
<span class="c1">--- over :: Lens s a -&gt; (a -&gt; a) -&gt; s -&gt; a</span>
<span class="kr">let</span> <span class="n">newX</span> <span class="o">=</span> <span class="n">over</span> <span class="p">(</span><span class="n">aLens</span> <span class="o">.</span> <span class="n">bLens</span> <span class="o">.</span> <span class="n">cLens</span><span class="p">)</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">x</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>When people say lenses are more powerful than traditional getters/setters, this is what they mean. Because lenses are just ordinary data, we can manipulate them like anything else and define custom behavior (in this case <code class="language-plaintext highlighter-rouge">over</code> for <em>modifying</em> a field, rather than <code class="language-plaintext highlighter-rouge">set</code>).</p>

<p>Lenses are just one example of an <strong>optic</strong>. For instance, <strong>prisms</strong> are another type of optic that adapts the lens concept to sum types.</p>]]></content><author><name></name></author><category term="Programming" /><category term="functional programming" /><category term="haskell" /><category term="programming" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Monads are just monoids in the category of endofunctors, what’s the problem?</title><link href="/posts/monads-monoids/" rel="alternate" type="text/html" title="Monads are just monoids in the category of endofunctors, what’s the problem?" /><published>2020-06-29T12:00:00+12:00</published><updated>2023-06-29T12:00:00+12:00</updated><id>/posts/monads-monoids</id><content type="html" xml:base="/posts/monads-monoids/"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>The title is from James Iry’s classic <a href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a>, an hilarious rundown of various programming languages. The statement was lifted from an observation in Saunders Mac Lane’s <em>Categories for The Working Mathematician</em>:</p>

<blockquote>
  <p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
</blockquote>

<p>Monads are known for being difficult to learn, and this phrase is a well-known joke in the functional programming community, the joke being that it doesn’t make sense to anyone who doesn’t already understand it.</p>

<p>The goal of this post is to explain this statement to someone who knows some category theory (e.g. the definition of category, functor), but has yet to put the pieces together.</p>

<p>We will review the definitions in light detail, assuming familiarity. We will also omit some technical requirements, such as commutative diagrams and coherence conditions. To start, we will slightly amend the statement for clarity:</p>

<blockquote>
  <p>A monad is an example of a monoid in the category of endofunctors.</p>
</blockquote>

<p>Or in symbols,</p>

<blockquote>
  <p>\(M\) is a monad \(\implies M\) is a monoid in the category of endofunctors.</p>
</blockquote>

<p>Notice that the implication is one-way i.e. the converse is not necessarily true. More on this later.</p>

<h2 id="monoidal-categories">Monoidal categories</h2>

<p><strong>Definition:</strong> A <strong>monoidal category</strong> \((C, \otimes, I)\) is a category \(C\) equipped with</p>

<ul>
  <li>\(\otimes : C \times C \rightarrow C\), a bifunctor called the <strong>monoidal product</strong>.</li>
  <li>\(I\), an object in \(C\) that behaves like the identity with \(\otimes\).</li>
</ul>

<p><strong>Definition:</strong> A <strong>monoid object</strong>, or simply <strong>monoid</strong>, is an object \(A\) in \(C\) with two arrows:</p>

\[\begin{align*}
  &amp; \eta : I          &amp;&amp; \rightarrow A\\
  &amp; \mu : A \otimes A &amp;&amp; \rightarrow A
\end{align*}\]

<p><strong>Example:</strong> \((\textbf{Set}, \times, *)\) is a monoidal category where \(\times\) is cartesian product and \(*\) is any singleton set. A monoid object in this category is a set \(A\) with functions</p>

\[\begin{align*}
  &amp; \eta : *         &amp;&amp; \rightarrow A\\
  &amp; \mu : A \times A &amp;&amp; \rightarrow A
\end{align*}\]

<p>This yields the familiar definition of a monoid from abstract algebra i.e. a set with a binary function (\(\mu\)) and an identity (given by \(\eta\)).</p>

<p>To see this, consider the cyclic group \(\mathbb{Z}/n\mathbb{Z} := \{1, 2, \ldots, n\}\) and define functions</p>

\[\begin{align*}
  &amp; \eta(x)   &amp;&amp; = 0\\
  &amp; \mu(x, y) &amp;&amp; \equiv x + y \pmod n
\end{align*}\]

<p>This gives the monoidal structure and is equivalent to the more abstract definition given above.</p>

<h2 id="monads">Monads</h2>

<p><strong>Definition:</strong> Given a category \(C\), a <strong>monad</strong> is a triple \((T, \eta, \mu)\) with</p>

<ul>
  <li>\(T : C \rightarrow C\), an endofunctor on \(C\).</li>
  <li>Natural transformations:</li>
</ul>

\[\begin{align*}
  &amp; \eta : 1_C      &amp;&amp; \rightarrow T\\
  &amp; \mu : T \circ T &amp;&amp; \rightarrow T
\end{align*}\]

<p>where \(1_C\) is the identity functor on \(C\) and \(T \circ T\) is \(T\) composed with itself via <em>functor</em> composition. Note that \(T \circ T\) is sometimes written as \(T^2\).</p>

<p><strong>Example:</strong> Again consider \(\textbf{Set}\), and let \(T : \textbf{Set} \rightarrow \textbf{Set}\) be the power set functor. Then \((T, \eta, \mu)\) is a monad on \(\textbf{Set}\) where \(\eta\) maps each \(a \in A\) to \(\{a\}\), and \(\mu\) maps a nested set to its union. That is,</p>

\[\begin{align*}
  &amp; \eta(A) = \bigcup_{a \in A} \{a\} \\
  &amp; \mu(A) = \bigcup_{a \in A} a
\end{align*}\]

<h2 id="category-of-endofunctors">Category of endofunctors</h2>

<p><strong>Definition:</strong> Every category \(C\) gives rise to a category of endofunctors \(\text{End}_C\). The objects in this category are endofunctors \(T : C \rightarrow C\), and the arrows are natural transformations.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>\((\text{End}_C, \circ, 1_C)\) is a monoidal category. A monoid in this category, then, is an endofunctor \(T\) with natural transformations:</p>

\[\begin{align*}
  &amp; \eta : 1_C      &amp;&amp; \rightarrow T\\
  &amp; \mu : T \circ T &amp;&amp; \rightarrow T
\end{align*}\]

<p>This is exactly the definition of a monad! Putting it back into words:</p>

<blockquote>
  <p>A monad \((T, \eta, \mu)\) is a monoid in \((\text{End}_C, \circ, 1_C)\).</p>
</blockquote>

<h2 id="coda">Coda</h2>

<p>Remember this comment?</p>

<blockquote>
  <p>Notice that the implication is one-way i.e. the converse is not necessarily true.</p>
</blockquote>

<p>This is due to there being more than one way of defining a “monoid in the category of endofunctors”. We have taken the monoidal product \(\otimes\) to be \(\circ\), functor composition. In this case, yes, a monoid in this category is exactly a monad.</p>

<p>But observe that this definition leaves open the possibility of using a different monoidal product. In particular, we could take \(\otimes\) to be <a href="https://en.wikipedia.org/wiki/Day_convolution"><strong>Day Convolution</strong></a>, sometimes written as \(\star\). In this case we get a <em>different</em> “monoid in the category of endofunctors”, and in fact a monoid in this category is a <strong>lax monoidal functor</strong>, not a monad.</p>]]></content><author><name></name></author><category term="Math" /><category term="category theory" /><category term="math" /><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>