[ { "title": "Whence cometh optics?", "url": "/posts/optics/", "categories": "Programming", "tags": "functional programming, haskell, programming", "date": "2023-04-14 12:00:00 +1200", "snippet": "IntroductionOptics are a powerful tool in certain niche areas of programming, but they can be confusing and intimidating, especially for those coming from a more traditional programming background....", "content": "IntroductionOptics are a powerful tool in certain niche areas of programming, but they can be confusing and intimidating, especially for those coming from a more traditional programming background. What are optics, why would one use them, and should you care? This post will explore each of these questions.This is not a comprehensive overview of optics, nor is it an explanation of how they work. Rather, it is an introduction to the topic, motivated by the problem they were designed to solve.Classic Getters/SettersThe core concept involves data “getters and setters”, so let’s look at a traditional example:class Email { // i.e. local@domain String local = null; String domain = null; public Email(String local, String domain) { ... } public String getLocal() { return this.local; } public void setLocal(String local) { this.local = local; } public String getDomain() { return this.domain; } public void setDomain(String domain) { this.domain = domain; }}The getters (getLocal and getDomain) are used to retrieve the field while the setters (setLocal and setDomain) are used to set the field.// get fieldsString localVar = email.getLocal();String domainVar = email.getDomain();// set fieldsemail.setLocal(\"username\");email.setDomain(\"domain.com\");We can view getLocal as a function that takes an Email (implicit this) and returns a String. Similarly, setLocal can be viewed as a function that takes a String, an Email (this), and returns a new Email (modified this). That is:\\[\\begin{align*} &amp; \\text{getLocal} : \\text{Email} \\to \\text{String} \\\\ &amp; \\text{setLocal} : \\text{String} \\times \\text{Email} \\to \\text{Email}\\end{align*}\\]Together, a getter + setter pair for a given field represents a way to “focus” on a particular field.A nice thing about typical getters/setters is that they can be composed. That is, if I haveclass Customer { Integer id = 0; Email email = null; public Email getEmail() { return this.email; } public void setEmail(Email email) { this.email = email; }}Then we can compose the getters/setters together:String localVar = customer.getEmail().getLocal();customer.getEmail().setLocal(\"username\");Haskell Getters/SettersOptics are most commonly used in Haskell, so let’s look at how we would replicate the above java. First, let’s create the equivalent types.data Email = MkEmail { local :: String, domain :: String }data Customer = MkCustomer { id :: Integer, email :: Email }With this “record syntax” haskell gives us “selectors” that are similar to java getters/setters.-- analogous to \"email.getLocal()\". Notice this is \"backwards\" as the 'local'-- and 'domain' \"fields\" are essentially functions.---- local : Email -&gt; String-- domain : Email -&gt; Stringlet localVar :: String localVar = local email domainVar :: String domainVar = domain emailUpdates are more interesting. Data in haskell is immutable i.e. once you declare something it is constant; it cannot be changed. This is an enormously useful feature, but it poses a problem. Even if we do not need true mutability, we often want to model it. How do we do this in an immutable world? Well, we have to create new data that copies the old fields over together with the new field.-- How we implement email.setLocal(\"username\"). Analogous to-- Email newEmail = new Email(\"username\", email.getDomain())let newEmail :: Email newEmail = MkEmail \"username\" (domain email)Luckily, haskell provides an “update syntax” that makes this more reasonable.-- Analogous to email.setLocal(\"username\")let newEmail :: Email newEmail = email { local = \"username\" }Make no mistake, in neither case are we actually modifying the original email. It is constant. We are creating a new email with the fields we want, thus modeling mutability, which is usually all we need.The problemSo far this works well, ergonomics notwithstanding. What about the nested case? Getting works fine:-- customer.getEmail().getLocal()let localVar :: String localVar = local (email customer)It is update that is the problem. The update syntax we saw earlier cannot be nested. That is, the following is not legal:-- customer.getEmail().setLocal(\"username\")let newCustomer :: Customer newCustomer = customer { email = { local = \"username\" } }We are thus stuck copying fields manually:let -- newEmail = customer.getEmail().set(\"username\"); newEmail :: Email newEmail = (email customer) { local = \"username\" } -- newCustomer = new Customer(customer.getId(), newEmail) newCustomer :: Customer newCustomer = MkCustomer (id customer) newEmailIt is as if we had to do the following in java:// rather than customer.getEmail().setLocal(\"username\")// create newEmail with the new fieldEmail newEmail = new Email(\"username\", email.getDomain());// create a new Customer w/ our changed fieldCustomer customer = new Customer(customer.getId(), newEmail);Obviously this does not scale at all. Something like:x.getA().getB().setC(new C(5));would becomeC newC = new C(5);B newB = new B(newC);A newA = new A(newB);x newX = new X(newA);In other words, nested updates and immutable data do not mix well. It is this problem that optics are designed to solve.LensesThere are many types of optics, but for our purposes we will only consider lenses, arguably the easiest to motivate. Lenses take the idea of a “getter/setter pair” and turn this into actual data. Without getting into the implementation, a lens in haskell looks something like:emailLocalLens :: Lens Email StringThat is, emailLocalLens represents the concept of “getting and setting the field local” on the type Email. This gives us an alternative to the selectors used before:-- Like email.getLocal(). 'view' is a function that takes in a lens, data and-- \"activates\" the getter portion of the lens to get the desired field. Morally,---- view :: Lens s a -&gt; s -&gt; alet localVar :: String localVar = view emailLocalLens email-- Like email.setLocal(\"username\"). 'set' is a function that takes in a lens, the-- new value, data and \"activates\" the setter portion of the lens to set the-- desired field. Morally,---- set :: Lens s a -&gt; a -&gt; s -&gt; slet newEmail :: Email newEmail = set emailLocalLens \"username\" emailThis is why lenses are referred to as “first class getters/setters”. Rather than having some syntax built into the language (e.g. java methods), lenses are just like anything else in haskell: a type we can define ourselves that implements the “getter/setter” concept with respect to some data.At this point you would be forgiven for wondering what that point is. This seems like a lot of work just to come up with a worse syntax. Why go through all this trouble? The crucial advantage that lenses have over traditional haskell updates is that they can be composed. Remember the previous example?let newEmail = email { local = \"username\" } newCustomer = MkCustomer newEmailWith lenses we don’t have to manually copy over all the old data:-- customerEmailLens is a lens for the email field on the Customer typecustomerEmailLens :: Lens Customer Emaillet -- We can freely compose (combine) lenses together customerLocalLens :: Lens Customer String customerLocalLens = customerEmailLens . emailLocalLens newCustomer :: Customer newCustomer = set customerLocalLens \"username\" customerThe advantage is easily seen with the “extreme” example:x.getA().getB().setC(new C(5));let newX = set (aLens . bLens . cLens) 5 xThus we arrive at the primary motivation. Even if we do not need true mutability, we often need to model it. This can be quite difficult with immutable data. Unless our language provides special syntax for it, we have to manually recreate the data. Lenses exist to recover the ergonomics of mutability (i.e. nested getters/setters) in an immutable world.Should you care?If you are working in an environment with immutable data then lenses (and other optics) are certainly worth being aware of. They are never necessary, but they can make life much easier.However, this is not the world inhabited by most programming. For better or worse, most programming languages fully embrace true mutability, thus we immediately have access to nested getters/setters. In this world, should you care about lenses?Probably not, as a major motivator is gone. Java doesn’t have this problem as all data is mutable, thus there is little need to torture yourself trying to implement lenses in java (of course, masochism exists).To put it more directly, you do not typically want to use lenses for their own sake, as an alternative to normal getters/setters. You use them because you want to use immutable data, and lenses help immutability suck less.AddendumWhile composition is the primary motivation for lenses, it isn’t the only advantage.In java you are mildly screwed if you want to update a field, rather than just set it.C c = x.getA().getB().getC();c.setVal(c.getVal() + 1); // can't do this inlinex.getA().getB().setC(c);Lenses handle this just fine:-- 'over' takes in a lens, a _function_, and the data to modify. Morally,----- over :: Lens s a -&gt; (a -&gt; a) -&gt; s -&gt; alet newX = over (aLens . bLens . cLens) (+1) xWhen people say lenses are more powerful than traditional getters/setters, this is what they mean. Because lenses are just ordinary data, we can manipulate them like anything else and define custom behavior (in this case over for modifying a field, rather than set).Lenses are just one example of an optic. For instance, prisms are another type of optic that adapts the lens concept to sum types." }, { "title": "Monads are just monoids in the category of endofunctors, what's the problem?", "url": "/posts/monads-monoids/", "categories": "Math", "tags": "category theory, math", "date": "2020-06-29 12:00:00 +1200", "snippet": "IntroductionThe title is from James Iry’s classic A Brief, Incomplete, and Mostly Wrong History of Programming Languages, an hilarious rundown of various programming languages. The statement was li...", "content": "IntroductionThe title is from James Iry’s classic A Brief, Incomplete, and Mostly Wrong History of Programming Languages, an hilarious rundown of various programming languages. The statement was lifted from an observation in Saunders Mac Lane’s Categories for The Working Mathematician: All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.Monads are known for being difficult to learn, and this phrase is a well-known joke in the functional programming community, the joke being that it doesn’t make sense to anyone who doesn’t already understand it.The goal of this post is to explain this statement to someone who knows some category theory (e.g. the definition of category, functor), but has yet to put the pieces together.We will review the definitions in light detail, assuming familiarity. We will also omit some technical requirements, such as commutative diagrams and coherence conditions. To start, we will slightly amend the statement for clarity: A monad is an example of a monoid in the category of endofunctors.Or in symbols, \\(M\\) is a monad \\(\\implies M\\) is a monoid in the category of endofunctors.Notice that the implication is one-way i.e. the converse is not necessarily true. More on this later.Monoidal categoriesDefinition: A monoidal category \\((C, \\otimes, I)\\) is a category \\(C\\) equipped with \\(\\otimes : C \\times C \\rightarrow C\\), a bifunctor called the monoidal product. \\(I\\), an object in \\(C\\) that behaves like the identity with \\(\\otimes\\).Definition: A monoid object, or simply monoid, is an object \\(A\\) in \\(C\\) with two arrows:\\[\\begin{align*} &amp; \\eta : I &amp;&amp; \\rightarrow A\\\\ &amp; \\mu : A \\otimes A &amp;&amp; \\rightarrow A\\end{align*}\\]Example: \\((\\textbf{Set}, \\times, *)\\) is a monoidal category where \\(\\times\\) is cartesian product and \\(*\\) is any singleton set. A monoid object in this category is a set \\(A\\) with functions\\[\\begin{align*} &amp; \\eta : * &amp;&amp; \\rightarrow A\\\\ &amp; \\mu : A \\times A &amp;&amp; \\rightarrow A\\end{align*}\\]This yields the familiar definition of a monoid from abstract algebra i.e. a set with a binary function (\\(\\mu\\)) and an identity (given by \\(\\eta\\)).To see this, consider the cyclic group \\(\\mathbb{Z}/n\\mathbb{Z} := \\{1, 2, \\ldots, n\\}\\) and define functions\\[\\begin{align*} &amp; \\eta(x) &amp;&amp; = 0\\\\ &amp; \\mu(x, y) &amp;&amp; \\equiv x + y \\pmod n\\end{align*}\\]This gives the monoidal structure and is equivalent to the more abstract definition given above.MonadsDefinition: Given a category \\(C\\), a monad is a triple \\((T, \\eta, \\mu)\\) with \\(T : C \\rightarrow C\\), an endofunctor on \\(C\\). Natural transformations:\\[\\begin{align*} &amp; \\eta : 1_C &amp;&amp; \\rightarrow T\\\\ &amp; \\mu : T \\circ T &amp;&amp; \\rightarrow T\\end{align*}\\]where \\(1_C\\) is the identity functor on \\(C\\) and \\(T \\circ T\\) is \\(T\\) composed with itself via functor composition. Note that \\(T \\circ T\\) is sometimes written as \\(T^2\\).Example: Again consider \\(\\textbf{Set}\\), and let \\(T : \\textbf{Set} \\rightarrow \\textbf{Set}\\) be the power set functor. Then \\((T, \\eta, \\mu)\\) is a monad on \\(\\textbf{Set}\\) where \\(\\eta\\) maps each \\(a \\in A\\) to \\(\\{a\\}\\), and \\(\\mu\\) maps a nested set to its union. That is,\\[\\begin{align*} &amp; \\eta(A) = \\bigcup_{a \\in A} \\{a\\} \\\\ &amp; \\mu(A) = \\bigcup_{a \\in A} a\\end{align*}\\]Category of endofunctorsDefinition: Every category \\(C\\) gives rise to a category of endofunctors \\(\\text{End}_C\\). The objects in this category are endofunctors \\(T : C \\rightarrow C\\), and the arrows are natural transformations.Putting it all together\\((\\text{End}_C, \\circ, 1_C)\\) is a monoidal category. A monoid in this category, then, is an endofunctor \\(T\\) with natural transformations:\\[\\begin{align*} &amp; \\eta : 1_C &amp;&amp; \\rightarrow T\\\\ &amp; \\mu : T \\circ T &amp;&amp; \\rightarrow T\\end{align*}\\]This is exactly the definition of a monad! Putting it back into words: A monad \\((T, \\eta, \\mu)\\) is a monoid in \\((\\text{End}_C, \\circ, 1_C)\\).CodaRemember this comment? Notice that the implication is one-way i.e. the converse is not necessarily true.This is due to there being more than one way of defining a “monoid in the category of endofunctors”. We have taken the monoidal product \\(\\otimes\\) to be \\(\\circ\\), functor composition. In this case, yes, a monoid in this category is exactly a monad.But observe that this definition leaves open the possibility of using a different monoidal product. In particular, we could take \\(\\otimes\\) to be Day Convolution, sometimes written as \\(\\star\\). In this case we get a different “monoid in the category of endofunctors”, and in fact a monoid in this category is a lax monoidal functor, not a monad." } ]
