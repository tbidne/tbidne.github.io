[ { "title": "Haskell records", "url": "/posts/haskell-records/", "categories": "Programming", "tags": "functional programming, haskell, programming", "date": "2024-02-29 09:00:00 +1300", "snippet": "IntroductionHaskell records appear simple, but this simplicity belies some significant drawbacks. While there are a plethora of libraries and language extensions that improve ergonomics, the trade-...", "content": "IntroductionHaskell records appear simple, but this simplicity belies some significant drawbacks. While there are a plethora of libraries and language extensions that improve ergonomics, the trade-offs are not immediately obvious.This post describes two of the most popular approaches, with an eye towards future improvements.Records, a backgroundBy records, we mean product types that have named fields. For example:class Employee { String name; String title; int age; class Employee(String n, String t, Int a) { this.name = n; this.title = t; this.age = a; } static String greetEmployee(Employee e) { return \"Hello \" + e.name + \"!\"; }}We have a type representing an employee that includes fields for a name, title, and age. Not only do we have the fields themselves, we associate a name with them. To see why this matters, consider the following haskell code:data Employee = MkEmployee String String IntmkEmployee :: String -&gt; String -&gt; Int -&gt; EmployeemkEmployee name title age = MkEmployee name title agegreetEmployee :: Employee -&gt; StringgreetEmployee (MkEmployee n _ _) = \"Hello \" ++ n ++ \"!\"Like the java example, this declares an Employee type that takes two strings and an int. Unlike the java example, however, the fields are unnamed. To access them we have to use pattern-matching. The downside is that we have to remember which field is which. This is especially problematic when we have multiple fields with the same type. For instance, the following code typechecks, yet is clearly a mistake, as we use the field intended for the title, not the name:greetEmployee :: Employee -&gt; StringgreetEmployee (MkEmployee _ t _) = \"Hello \" ++ t ++ \"!\"Not only is it easy to make mistakes, it also means we need to modify greetEmployee any time we add or remove a field from Employee.Fortunately, haskell provides “record syntax” that allows us to name fields:data Employee = MkEmployee { name :: String, title :: String, age :: Int }mkEmployee :: String -&gt; String -&gt; Int -&gt; EmployeemkEmployee n t a = MkEmployee { name = n, title = t, age = a }greetEmployee :: Employee -&gt; StringgreetEmployee e = \"Hello \" ++ name e ++ \"!\"Much better! Pattern matching still works, but we can now use the names to write clearer code that is less vulnerable to updates. All is well, right?All is not wellProblem 1: Duplicate Field NamesSuppose we want to create two types with the same field name:data Employee = MkEmployee { name :: String, title :: String, age :: Int }data Company = MkCompany { name :: String, employee :: Employee -- it's a small company, okay? }Unfortunately, these will not compile in the same module! The problem is that haskell’s record syntax essentially generates “field selectors” for each field i.e. for Employee:name :: Employee -&gt; Stringname (MkEmployee n _ _) = ntitle :: Employee -&gt; Stringtitle (MkEmployee _ t _) = nage :: Employee -&gt; Intage (MkEmployee _ _ a) = aSo if we try to compile Employee and Company we’d have:name :: Employee -&gt; Stringname (MkEmployee n _ _) = nname :: Company -&gt; Stringname (MkCompany n _) = nBut we cannot have two top-level functions with the same name, hence the error.1 The work-around is to declare these data types in different modules, and then qualify their usage:-- Employee.hsdata Employee = ...-- Company.hsdata Company = ...-- Lib.hsmodule Lib whereimport Company (Company)import Company qualified as Companyimport Employee (Employee)import Employee qualified as Employeemsg :: Company -&gt; Stringmsg c = Employee.name (Company.employee c) ++ \" works at \" ++ Company.name cThis works, but isn’t terribly satisfying.Problem 2: Nested UpdatesHaskell’s record syntax offers a further convenience; we can model updates:setName :: Employee -&gt; String -&gt; EmployeesetName e newName = e { name = newName }The setName function takes an employee e, new name newName, and returns a new employee e' that is the same as e except its name is newName. This is useful as it means we do not have to manually copy over unchanged fields when we want to change just one.There is a limitation, however: nested updates do not compose. That is, there is nothing like the following pseudo-syntax:setEmployeeName :: Company -&gt; String -&gt; CompanysetEmployeeName c newEmpName = c { employee = employee { name = newEmpName } }In other words, while update syntax allows us to update e.g. company.employee and employee.name, it does not work to update company.employee.name. This is unfortunate, as it greatly increases the difficulty of working with immutable data.2Solution 1: OverloadedRecordDotThis is the simplest solution that will be the most familiar to users with experience in mainstream languages.GHC 9.2 introduced the -XOverloadedRecordDot extension. With it, we can rewrite our modules as follows:{-# LANGUAGE DuplicateRecordFields #-} -- we need this too{-# LANGUAGE OverloadedRecordDot #-}module Data wheredata Employee = MkEmployee { name :: String, title :: String, age :: Int }data Company = MkCompany { name :: String, employee :: Employee }msg :: Company -&gt; Stringmsg c = c.employee.name ++ \" works at \" ++ c.nameMuch nicer! Not only is this more concise and familiar, it allows both definition and usage of duplicate record fields, completely solving problem 1. Note that the record field needs to be in scope in order to use it. For example: module Foo whereimport Data (Company (name)) -- need to import name heregetCompanyGreeting :: Company -&gt; StringgetCompanyGreeting c = c.name ++ \" welcomes you\" Don’t get too excited just yetWhile this neatly solves the problem of duplicate names, this does not help with nested updates. In fact, -XOverloadedRecordDot does not work for updates at all. For that, we need another extension, -XOverloadedRecordUpdate, plus some boilerplate. Brace yourself:{-# LANGUAGE AllowAmbiguousTypes #-}{-# LANGUAGE DataKinds #-}{-# LANGUAGE DuplicateRecordFields #-}{-# LANGUAGE FlexibleInstances #-}{-# LANGUAGE FunctionalDependencies #-}{-# LANGUAGE OverloadedRecordDot #-}{-# LANGUAGE OverloadedRecordUpdate #-}{-# LANGUAGE PolyKinds #-}{-# LANGUAGE RebindableSyntax #-}{-# LANGUAGE ScopedTypeVariables #-}{-# LANGUAGE TypeApplications #-}{-# LANGUAGE TypeSynonymInstances #-}module Data whereimport Prelude-- Because of RebindableSyntax, we need to declare the HasField class,-- getField, and setField ourselves.class HasField x r a | x r -&gt; a where hasField :: r -&gt; (a -&gt; r, a)getField :: forall x r a . HasField x r a =&gt; r -&gt; agetField = snd . hasField @xsetField :: forall x r a . HasField x r a =&gt; r -&gt; a -&gt; rsetField = fst . hasField @xdata Employee = MkEmployee { name :: String, title :: String, age :: Int }-- manually write instances for each field that we wantinstance HasField \"name\" Employee String where hasField e@(MkEmployee name title age) = (\\n -&gt; MkEmployee n title age, name)data Company = MkCompany { name :: String, employee :: Employee }instance HasField \"employee\" Company Employee where hasField c@(MkCompany name employee) = (\\e -&gt; MkCompany name e, employee)-- now we can use itsetEmployeeName :: Company -&gt; String -&gt; CompanysetEmployeeName c newEmpName = c { employee.name = newEmpName }Yikes! As you can see, this is a far-cry from the simplicity of -XOverloadedRecordDot. The unfortunate truth is that as of GHC 9.8, -XOverloadedRecordUpdate is a bit of a hack. It relies on several other extensions – including the huge hammer -XRebindableSyntax – which can break all sorts of normal code.Even the docs explicitly warn against using it.There is good news, however. A proposal to improve the situation was accepted in October 2023, and updates should work after this is implemented. This will not cover all use cases: type-changing updates will not immediately be supported. But this will easily cover typical record usage.Solution 2: OpticsOptics provide a second solution. Unlike -XOverloadedRecordDot, optics are not built-in; they are implemented at the library level. Not only do we therefore have to choose an optics library (there are many), there are often more choices to make. Here we choose optics-core (and optics-th for generating optics automatically) with -XOverloadedLabels style:{-# LANGUAGE DataKinds #-}{-# LANGUAGE DuplicateRecordFields #-}{-# LANGUAGE FlexibleInstances #-}{-# LANGUAGE MultiParamTypeClasses #-}{-# LANGUAGE OverloadedLabels #-}{-# LANGUAGE TemplateHaskell #-}{-# LANGUAGE TypeFamilies #-}{-# LANGUAGE UndecidableInstances #-}module Data whereimport Optics.Core (set, view, (%))import Optics.TH (makeFieldLabelsNoPrefix) -- optics-th librarydata Employee = MkEmployee { name :: String, title :: String, age :: Int }makeFieldLabelsNoPrefix ''Employeedata Company = MkCompany { name :: String, employee :: Employee }makeFieldLabelsNoPrefix ''Companymsg :: Company -&gt; Stringmsg c = view (#employee % #name) c ++ \" works at \" ++ view #name csetEmployeeName :: Company -&gt; String -&gt; CompanysetEmployeeName c newEmpName = set (#employee % #name) newEmpName cFirst, we use makeFieldLabelsNoPrefix from the optics-th library to generate lenses (a type of optic). After this, we can implement our getter and setter functions simply using the #&lt;field-name&gt; syntax. To compose two lenses together, we use the (%) operator from optics-core. For instance, the equivalent of myCompany.employee.name is view (#employee % #name) myCompany.Tell me the catchTemplateHaskell (used in makeFieldLabelsNoPrefix) has several drawbacks. One of the major annoyances is how it requires the source code to be in a specific order. That is, normally you can reorder code in a Haskell module to your heart’s content:a :: Int -&gt; Inta x = f xf :: Int -&gt; Intf = ...-- It makes no difference whether 'f' or 'a' comes first in a haskell source file.f :: Int -&gt; Intf = ...a :: Int -&gt; Inta x = f xWith TH this is no longer true. In particular, if you want to use the result of TH, the code that uses it must come after the TH code.-- This works because the usage (msg) comes _after_ the TH definition-- (makeFieldLabelsNoPrefix)makeFieldLabelsNoPrefix ''Companymsg :: Company -&gt; Stringmsg c = view (#employee % #name) c ++ \" works at \" ++ view #name c-- The below will trigger a \"No instance for LabelOptic...\" errormsg :: Company -&gt; Stringmsg c = view (#employee % #name) c ++ \" works at \" ++ view #name cmakeFieldLabelsNoPrefix ''CompanyThis can lead to cryptic “No instance for LabelOptic…” errors when there are multiple TH definitions and usages in the same module (“What do you mean no instance? It’s right there.”).TH also comes with other drawbacks: Increases compilation time. Prevents cross-compilation.Thus we can drop the dependency on optics-th and hand-write our lenses instead:import Optics.Core (A_Lens, lensVL, set, view, (%))import Optics.Label (LabelOptic(labelOptic))-- makeFieldLabelsNoPrefix generates the below instances for each field.---- The reason for the convoluted equality constraints (e.g. k ~ A_Lens, ...)-- over writing them directly (instance LabelOptic \"name\" A_Lens ...) is-- improved type inference.---- The INLINEs are for performance.-- name lens for employeeinstance (k ~ A_Lens, a ~ String, b ~ String) =&gt; LabelOptic \"name\" k Employee Employee a b where labelOptic = lensVL nameLens where nameLens :: Functor f =&gt; (String -&gt; f String) -&gt; Employee -&gt; f Employee nameLens f (MkEmployee _name _title _age) = fmap (\\name' -&gt; MkEmployee name' _title _age) (f _name) {-# INLINE labelOptic #-}-- name lens for companyinstance (k ~ A_Lens, a ~ String, b ~ String) =&gt; LabelOptic \"name\" k Company Company a b where labelOptic = lensVL nameLens where nameLens :: Functor f =&gt; (String -&gt; f String) -&gt; Company -&gt; f Company nameLens f (MkCompany _name _employee) = fmap (\\name' -&gt; MkCompany name' _employee) (f _name) {-# INLINE labelOptic #-}-- employee lens for companyinstance (k ~ A_Lens, a ~ Employee, b ~ Employee) =&gt; LabelOptic \"employee\" k Company Company a b where labelOptic = lensVL employeeLens where employeeLens :: Functor f =&gt; (Employee -&gt; f Employee) -&gt; Company -&gt; f Company employeeLens f (MkCompany _name _employee) = fmap (\\employee' -&gt; MkCompany _name employee') (f _employee) {-# INLINE labelOptic #-}That’s it! A bit heavy on the boilerplate, but this solves both duplicate fields and nested updates without any TH drawbacks. Additionally, we receive nice features beyond normal getters and setters like modify.import Optics.Core (over)-- using 'over' to _modify_ a nested field rather than simply setting or-- getting it.incEmployeeAge :: Company -&gt; CompanyincEmployeeAge c = over (#employee % #age) (+1) cIn general, optics offer a powerful way to view and modify data, far surpassing what mere getters and setters can do.3ConclusionHaskell offers a useful record syntax for manipulating data, but this syntax comes with some shortcomings. We have shown two different ways to overcome this: The -XOverloadedRecordDot extension and the optics-core library. Which should you use?It depends.-XOverloadedRecordDot is undoubtedly simpler and friendlier to people coming from other languages. If the primary problem you face is duplicate record fields and you don’t need nested updates all that often, perhaps -XOverloadedRecordDot is the best choice (and nested updates are hopefully not too far away).If, on the other hand, you want the most complete, sophisticated way of handling data today, take the plunge, and explore how deep the optics rabbit-hole goes. There is an extension -XDuplicateRecordFields that overcomes this limitation. This only allows the definition – not actual usage – so it is not a complete solution. &#8617; I wrote about this problem as a motivator for optics here. &#8617; Not only can optics handle fields via lenses, but we can also manipulate sum types via prisms. A full description is beyond the scope of this article, however. &#8617; " }, { "title": "Whence cometh optics?", "url": "/posts/optics/", "categories": "Programming", "tags": "functional programming, haskell, programming", "date": "2023-04-14 12:00:00 +1200", "snippet": "IntroductionOptics are a powerful tool in certain niche areas of programming, but they can be confusing and intimidating, especially for those coming from a more traditional programming background....", "content": "IntroductionOptics are a powerful tool in certain niche areas of programming, but they can be confusing and intimidating, especially for those coming from a more traditional programming background. What are optics, why would one use them, and should you care? This post will explore each of these questions.This is not a comprehensive overview of optics, nor is it an explanation of how they work. Rather, it is an introduction to the topic, motivated by the problem they were designed to solve.Classic Getters/SettersThe core concept involves data “getters and setters”, so let’s look at a traditional example:class Email { // i.e. local@domain String local = null; String domain = null; public Email(String local, String domain) { this.local = local; this.domain = domain; } public String getLocal() { return this.local; } public void setLocal(String local) { this.local = local; } public String getDomain() { return this.domain; } public void setDomain(String domain) { this.domain = domain; }}We have a type Email for representing email addresses with two fields: local and domain.The getters (getLocal and getDomain) are used to retrieve the field while the setters (setLocal and setDomain) are used to set the field.Email emailVar = new Email (\"user\", \"domain.com\");// get fieldsString localVar = emailVar.getLocal();String domainVar = emailVar.getDomain();// set fieldsemailVar.setLocal(\"new_user\");emailVar.setDomain(\"new_domain.com\");We can view getLocal as a function that takes an Email (implicit this) and returns a String. Similarly, setLocal can be viewed as a function that takes a String, an Email (this), and returns a new Email (modified this). That is:\\[\\begin{align*} &amp; \\text{getLocal} : \\text{Email} \\to \\text{String} \\\\ &amp; \\text{setLocal} : \\text{String} \\times \\text{Email} \\to \\text{Email}\\end{align*}\\]Together, a getter + setter pair for a given field represents a way to “focus” on a particular field.An important feature of getters/setters is that they can be composed. That is, if we haveclass Customer { Integer cid = 0; Email email = null; public Email getEmail() { return this.email; } public void setEmail(Email email) { this.email = email; }}Then we can compose the getters/setters together:Customer customerVar = new Customer (...);String domainVar = customerVar.getEmail().getDomain();customerVar.getEmail().setDomain(\"new_domain.com\");We can therefore carry out an arbitrarily deep “get” or “set”, simply with composition.Haskell Getters/SettersOptics are most commonly used in Haskell, so let’s look at how we would replicate the above java. First, let’s create the equivalent types.data Email = MkEmail { local :: String, domain :: String }data Customer = MkCustomer { cid :: Integer, email :: Email }With this “record syntax”, haskell gives us “selectors” that are similar to java getters/setters.let emailVar :: Email emailVar = MkEmail \"user\" \"domain.com\"-- analogous to \"email.getLocal()\". Notice this is \"backwards\" as the 'local'-- and 'domain' fields are essentially functions.---- local : Email -&gt; String-- domain : Email -&gt; Stringlet localVar :: String localVar = local emailVar domainVar :: String domainVar = domain emailVarUpdates are more interesting. Data in haskell is immutable i.e. once you declare something it is constant; it cannot be changed. This is an enormously useful feature, but it poses a problem. Even if we do not need true mutability, we often want to model it. How do we do this in an immutable world? Well, we have to create new data that copies the old fields over together with the new field.-- Replicating emailVar.setDomain(\"new_domain.com\"). Analogous to-- Email newEmail = new Email(emailVar.getLocal(), \"new_domain.com\")let newEmail :: Email newEmail = MkEmail (local emailVar) \"new_domain.com\"There is also a record syntax for creation, which can be clearer, if also less concise.let newEmail = MkEmail { local = local emailVar, domain = \"new_domain.com\" }Make no mistake, in neither case are we modifying the original emailVar. It is constant. We are creating a new email with the fields we want, thus modeling mutability, which is usually all we need.1The problemSo far this works well, ergonomics notwithstanding. What about the nested case? Getting works fine:-- customerVar.getEmail().getDomain()let domainVar :: String domainVar = domain (email customerVar)It is update that is the problem. If we want to update a field, we have to recreate the entire data structure with our new field.let -- recreate emailVar with new domain newEmail = MkEmail { local = local emailVar, domain = \"new_domain.com\" } -- recreate customerVar with new email newCustomer = MkCustomer { cid = cid customerVar, email = newEmail }It is as if we had to do the following in java:// rather than customerVar.getEmail().setDomain(\"new_domain.com\")// create newEmail with the new fieldEmail newEmail = new Email(emailVar.getLocal(), \"new_domain.com\");// create a new Customer w/ our changed fieldCustomer newCustomer = new Customer(customerVar.getCid(), newEmail);Obviously this does not scale at all. Something like:x.getA().getB().setC(new C(5));would becomeC newC = new C(5);B newB = new B(newC);A newA = new A(newB);X newX = new X(newA);Cthulhu help you if your data is complicated (e.g. has many fields, lists, etc.). In other words, nested updates and immutable data do not mix well. It is this problem that optics are designed to solve.LensesThere are many types of optics, but for our purposes we will only consider lenses, arguably the easiest to motivate. Lenses take the idea of a “getter/setter pair” and turn it into actual data. Without getting into the implementation, a lens in haskell looks something like:emailDomainLens :: Lens Email StringThat is, emailDomainLens represents the concept of “getting and setting the String field domain” on the type Email. This gives us an alternative to the selectors used before:-- Like email.getDomain(). 'view' is a function that takes in a lens, data, and-- \"activates\" the getter portion of the lens to get the desired field. Morally,---- view :: Lens s a -&gt; s -&gt; alet domainVar :: String -- Instead of: domainVar = domain emailVar domainVar = view emailDomainLens emailVar-- Like email.setDomain(\"new_domain.com\"). 'set' is a function that takes in a lens, the-- new value, data, and \"activates\" the setter portion of the lens to set the-- desired field. Morally,---- set :: Lens s a -&gt; a -&gt; s -&gt; slet newEmail :: Email -- Instead of: newEmail = MkEmail (local emailVar) \"new_domain.com\" newEmail = set emailDomainLens \"new_domain.com\" emailVarThis is why lenses are referred to as “first class getters/setters”. Rather than having some syntax built into the language (e.g. java methods), lenses are just like anything else in haskell: a type we can define ourselves that implements the “getter/setter” concept with respect to some data.At this point you would be forgiven for wondering what the big deal is. This seems like a lot of work just to come up with a worse syntax. Why go through all this trouble? The crucial advantage that lenses have over traditional haskell updates is that they can be composed. Remember the previous example?let newEmail = MkEmail { local = local emailVar, domain = \"new_domain.com\" } newCustomer = MkCustomer { cid = cid customerVar, email = newEmail }The fundamental problem is that while we can fairly easily update customer.email and email.domain, we cannot compose these to easily update customer.email.domain. Lenses do not have this problem. If we have a Lens a b and a Lens b c, then we can easily form a Lens a c.-- customerEmailLens is a lens for the Email field on the Customer typecustomerEmailLens :: Lens Customer Emaillet -- We can freely compose (combine) lenses together e.g. -- -- innerLens :: Lens s a -- outerLens :: Lens t s -- -- (outerLens . innerLens) :: Lens t a customerDomainLens :: Lens Customer String customerDomainLens = customerEmailLens . emailDomainLens -- we now have our customerVar.getEmail().setDomain(\"new_domain.com\")! newCustomer :: Customer newCustomer = set customerDomainLens \"new_domain.com\" customerVarThe advantage is easily seen with the “extreme” example:x.getA().getB().setC(new C(5));-- composition FTWlet newX = set (aLens . bLens . cLens) 5 xThus we arrive at the primary motivation. Even if we do not need true mutability, we often need to model it. This can be quite difficult with immutable data. Unless our language provides special syntax for it, we have to manually recreate the data. Lenses exist to recover the ergonomics of mutability (i.e. nested getters/setters) in an immutable world.Should you care?For working with immutable data, it is certainly worth being aware of lenses (and other optics). They are never necessary, but they can make life much easier.However, this is not the world inhabited by most programming. For better or worse, most programming languages fully embrace true mutability, thus we immediately have access to nested getters/setters. In this world, should you care about lenses?Probably not, as a major motivator is gone. Java doesn’t have this problem as all data is mutable, thus there is little need to torture yourself trying to implement lenses in java (of course, masochism exists).2To put it more directly, you do not typically want to use lenses for their own sake, as an alternative to normal getters/setters. You use them because you want to use immutable data, and lenses make immutability less painful.AddendumWhile composition is the primary motivation for lenses, it isn’t the only advantage.In java you are mildly screwed if you want to update a field, rather than just set it.C c = x.getA().getB().getC();c.setVal(c.getVal() + 1); // can't do this inlinex.getA().getB().setC(c);Lenses handle this just fine:-- 'over' takes in a lens, a _function_, and the data to modify. Morally,----- over :: Lens s a -&gt; (a -&gt; a) -&gt; s -&gt; slet newX = over (aLens . bLens . cLens) (+1) xWhen people say lenses are more powerful than traditional getters/setters, this is what they mean. Because lenses are just ordinary data, we can manipulate them like anything else and define custom behavior (in this case over for modifying a field, rather than mere set).Lenses are just one example of an optic. For instance, prisms are another type of optic that adapts the lens concept to sum types. Technically haskell has “update syntax” for this that looks like newEmail = emailVar { domain = \"new_domain.com\" }. But we cannot “nest” updates (i.e. it does not compose), thus it is not a general solution to the described problem. &#8617; Not to mention, it is not possible to implement lenses (or other optics) in most languages as the concept requires Higher-Kinded Types (think “nested generics” e.g. F&lt;A&gt;), which very few languages support. It is only achievable in Java through an impressive yet hideous hack. &#8617; " }, { "title": "Monads are just monoids in the category of endofunctors, what's the problem?", "url": "/posts/monads-monoids/", "categories": "Math", "tags": "category theory, math", "date": "2020-06-29 12:00:00 +1200", "snippet": "IntroductionThe title is from James Iry’s classic A Brief, Incomplete, and Mostly Wrong History of Programming Languages, an hilarious rundown of various programming languages. The statement was li...", "content": "IntroductionThe title is from James Iry’s classic A Brief, Incomplete, and Mostly Wrong History of Programming Languages, an hilarious rundown of various programming languages. The statement was lifted from an observation in Saunders Mac Lane’s Categories for The Working Mathematician: All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.Monads are known for being difficult to learn, and this phrase is a well-known joke in the functional programming community, the joke being that it doesn’t make sense to anyone who doesn’t already understand it.The goal of this post is to explain this statement to someone who knows some category theory (e.g. the definition of category, functor), but has yet to put the pieces together.We will review the definitions in light detail, assuming familiarity. We will also omit some technical requirements, such as commutative diagrams and coherence conditions. To start, we will slightly amend the statement for clarity: A monad is an example of a monoid in the category of endofunctors.Or in symbols, \\(M\\) is a monad \\(\\implies M\\) is a monoid in the category of endofunctors.Notice that the implication is one-way i.e. the converse is not necessarily true. More on this later.Monoidal categoriesDefinition: A monoidal category \\((C, \\otimes, I)\\) is a category \\(C\\) equipped with \\(\\otimes : C \\times C \\rightarrow C\\), a bifunctor called the monoidal product. \\(I\\), an object in \\(C\\) that behaves like the identity with \\(\\otimes\\).Definition: A monoid object, or simply monoid, is an object \\(A\\) in \\(C\\) with two arrows:\\[\\begin{align*} &amp; \\eta : I &amp;&amp; \\rightarrow A\\\\ &amp; \\mu : A \\otimes A &amp;&amp; \\rightarrow A\\end{align*}\\]Example: \\((\\textbf{Set}, \\times, *)\\) is a monoidal category where \\(\\times\\) is cartesian product and \\(*\\) is any singleton set. A monoid object in this category is a set \\(A\\) with functions\\[\\begin{align*} &amp; \\eta : * &amp;&amp; \\rightarrow A\\\\ &amp; \\mu : A \\times A &amp;&amp; \\rightarrow A\\end{align*}\\]This yields the familiar definition of a monoid from abstract algebra i.e. a set with a binary function (\\(\\mu\\)) and an identity (given by \\(\\eta\\)).To see this, consider the cyclic group \\(\\mathbb{Z}/n\\mathbb{Z} := \\{1, 2, \\ldots, n\\}\\) and define functions\\[\\begin{align*} &amp; \\eta(x) &amp;&amp; = 0\\\\ &amp; \\mu(x, y) &amp;&amp; \\equiv x + y \\pmod n\\end{align*}\\]This gives the monoidal structure and is equivalent to the more abstract definition given above.MonadsDefinition: Given a category \\(C\\), a monad is a triple \\((T, \\eta, \\mu)\\) with \\(T : C \\rightarrow C\\), an endofunctor on \\(C\\). Natural transformations:\\[\\begin{align*} &amp; \\eta : 1_C &amp;&amp; \\rightarrow T\\\\ &amp; \\mu : T \\circ T &amp;&amp; \\rightarrow T\\end{align*}\\]where \\(1_C\\) is the identity functor on \\(C\\) and \\(T \\circ T\\) is \\(T\\) composed with itself via functor composition. Note that \\(T \\circ T\\) is sometimes written as \\(T^2\\).Example: Again consider \\(\\textbf{Set}\\), and let \\(T : \\textbf{Set} \\rightarrow \\textbf{Set}\\) be the power set functor. Then \\((T, \\eta, \\mu)\\) is a monad on \\(\\textbf{Set}\\) where \\(\\eta\\) maps each \\(a \\in A\\) to \\(\\{a\\}\\), and \\(\\mu\\) maps a nested set to its union. That is,\\[\\begin{align*} &amp; \\eta(A) = \\bigcup_{a \\in A} \\{a\\} \\\\ &amp; \\mu(A) = \\bigcup_{a \\in A} a\\end{align*}\\]Category of endofunctorsDefinition: Every category \\(C\\) gives rise to a category of endofunctors \\(\\text{End}_C\\). The objects in this category are endofunctors \\(T : C \\rightarrow C\\), and the arrows are natural transformations.Putting it all together\\((\\text{End}_C, \\circ, 1_C)\\) is a monoidal category. A monoid in this category, then, is an endofunctor \\(T\\) with natural transformations:\\[\\begin{align*} &amp; \\eta : 1_C &amp;&amp; \\rightarrow T\\\\ &amp; \\mu : T \\circ T &amp;&amp; \\rightarrow T\\end{align*}\\]This is exactly the definition of a monad! Putting it back into words: A monad \\((T, \\eta, \\mu)\\) is a monoid in \\((\\text{End}_C, \\circ, 1_C)\\).CodaRemember this comment? Notice that the implication is one-way i.e. the converse is not necessarily true.This is due to there being more than one way of defining a “monoid in the category of endofunctors”. We have taken the monoidal product \\(\\otimes\\) to be \\(\\circ\\), functor composition. In this case, yes, a monoid in this category is exactly a monad.But observe that this definition leaves open the possibility of using a different monoidal product. In particular, we could take \\(\\otimes\\) to be Day Convolution, sometimes written as \\(\\star\\). In this case we get a different “monoid in the category of endofunctors”, and in fact a monoid in this category is a lax monoidal functor, not a monad." } ]
